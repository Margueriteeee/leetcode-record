你想了解 Python 中常用数据容器及其底层实现，这是算法面试的高频基础考点（比如面试官常会问「列表和元组的区别」「字典为什么查询快」），我会从「常用容器分类 → 底层实现 → 面试考点」三个维度，用初学者能听懂的语言讲清楚。

### 一、Python 常用数据容器（按用途分类）
先明确核心容器：**列表(list)、元组(tuple)、字典(dict)、集合(set)、字符串(str)**（字符串本质是字符的有序容器，常和列表归为一类）。
补充说明：这些容器的底层实现决定了它们的「时间复杂度」「可变性」「适用场景」——这也是面试考察的核心。

### 二、核心容器的底层实现（深入浅出版）
#### 1. 列表（list）—— 面试高频
**核心定位**：有序、可变、可重复的线性容器（日常用得最多）。
**底层实现**：**动态数组（Dynamic Array）**（不是普通数组）。
  - 普通数组：长度固定，Python 不直接暴露；
  - 动态数组：底层是一块连续的内存空间，但会预留「备用空间」。当列表元素满了，会自动申请更大的内存（通常是原大小的 1.5~2 倍），把原数据拷贝过去，再释放旧内存。
**面试关键细节**：
  - 优点：随机访问快（`list[i]`），时间复杂度 O(1)（因为连续内存，通过下标直接计算地址）；
  - 缺点：头部/中间插入/删除慢（O(n)）—— 因为要移动后面的元素；尾部操作（append/pop）大概率快（O(1)），只有扩容时是 O(n)；
  - 示例验证：
    ```python
    lst = [1,2,3]
    lst.append(4)  # 尾部添加，大概率O(1)
    lst.insert(0, 0)  # 头部插入，O(n)，需移动所有元素
    ```

#### 2. 元组（tuple）—— 面试常和列表对比
**核心定位**：有序、不可变、可重复的线性容器（常用于存固定数据）。
**底层实现**：**静态数组（Static Array）**（长度固定的连续内存）。
  - 不可变性：创建后内存空间固定，无法增删改元素（本质是内存地址和长度都锁定）；
  - 特殊点：如果元组里存的是可变对象（比如列表），对象内部可以改，但元组的元素引用不能改：
    ```python
    t = (1, [2,3])
    t[1].append(4)  # 可行，t变成 (1, [2,3,4])
    t[0] = 5  # 报错，元组元素不可改
    ```
**面试关键细节**：
  - 优点：比列表更节省内存（无扩容备用空间）、可哈希（能作为字典的 key）；
  - 缺点：不可变，无法修改，只能重新创建；
  - 应用场景：函数返回多个值、存储固定配置、作为字典 key 等。

#### 3. 字典（dict）—— 算法面试重中之重
**核心定位**：无序（Python 3.7+ 有序）、可变、键唯一的键值对容器（哈希表核心应用）。
**底层实现**：**哈希表（Hash Table）**（也叫散列表，结合「开放寻址法」解决哈希冲突）。
  - 核心逻辑：
    1. 对键（key）做哈希运算（`hash(key)`），得到一个整数；
    2. 用这个整数对哈希表的「桶数」取模，确定 key 对应的内存位置（桶）；
    3. 如果多个 key 哈希后落到同一个桶（哈希冲突），Python 用「开放寻址法」（找下一个空桶）解决，而非链表（和 Java 不同，面试常问）；
    4. 当哈希表的「负载因子」（元素数/桶数）超过阈值（默认 ~0.66），会扩容并重新哈希所有元素。
**面试关键细节**：
  - 优点：查询/新增/删除的平均时间复杂度 O(1)（这也是两数之和用字典优化的原因）；
  - 缺点：键必须是可哈希对象（不可变类型：int/str/tuple 等，list/set 不行）；扩容时性能暂时下降；
  - 示例验证：
    ```python
    d = {"a":1, "b":2}
    print(d["a"])  # O(1) 查询
    d["c"] = 3     # O(1) 新增
    ```

#### 4. 集合（set）—— 面试常和字典关联
**核心定位**：无序、可变、元素唯一的容器（常用于去重、集合运算）。
**底层实现**：**哈希表**（和字典几乎一样，只是只存 key，不存 value）。
  - 本质：字典的「键集合」—— 所以 set 的元素也必须是可哈希的，且不能重复；
  - 集合运算（交集 `&`、并集 `|`）的底层：遍历一个集合，用另一个集合的 O(1) 查询判断元素是否存在。
**面试关键细节**：
  - 去重效率：比列表遍历去重高（列表去重 O(n²)，set 去重 O(n)）；
  - 示例：
    ```python
    s = {1,2,2,3}  # 自动去重，变成 {1,2,3}
    print(2 in s)   # O(1) 查询
    ```

#### 5. 字符串（str）—— 面试常考不可变性
**核心定位**：有序、不可变、字符可重复的容器。
**底层实现**：**Unicode 字符数组（不可变）**。
  - 不可变性：字符串的任何修改（比如切片、拼接）都会生成新字符串，原字符串不变；
  - 优化点：Python 对小字符串有「字符串驻留池」（比如 `a="abc"` 和 `b="abc"` 指向同一个内存地址），节省内存。
**面试关键细节**：
  - 拼接效率：频繁拼接用 `''.join()` 而非 `+`（`+` 每次生成新字符串，`join` 预分配内存，O(n) 时间）；
  - 示例：
    ```python
    s = "abc"
    s2 = s + "d"  # 生成新字符串，原s不变
    s3 = ''.join([s, "d"])  # 高效拼接
    ```

### 三、面试高频对比表（核心考点）
| 容器   | 底层实现       | 可变性 | 有序性 | 查找时间复杂度 | 适用场景               |
|--------|----------------|--------|--------|----------------|------------------------|
| list   | 动态数组       | 可变   | 有序   | 下标O(1)/值O(n)| 有序数据、频繁尾部操作 |
| tuple  | 静态数组       | 不可变 | 有序   | 下标O(1)/值O(n)| 固定数据、字典key      |
| dict   | 哈希表         | 可变   | 3.7+有序| 键O(1)         | 键值对、快速查询       |
| set    | 哈希表（仅key）| 可变   | 无序   | 元素O(1)       | 去重、集合运算         |
| str    | 不可变字符数组 | 不可变 | 有序   | 字符O(1)/子串O(n)| 文本处理               |

### 总结（面试必记关键点）
1. **性能核心**：哈希表（dict/set）的查询/新增/删除是 O(1)，数组类（list/tuple/str）的下标访问是 O(1)、按值查找是 O(n)；
2. **可变性关键**：不可变容器（tuple/str）更节省内存、可哈希，但修改需重建；可变容器（list/dict/set）灵活但线程不安全（面试偶尔问）；
3. **选型思路**：面试做题时，需要快速查询/去重选 dict/set，需要有序修改选 list，需要固定数据选 tuple。

## 链表实现 VS 数组
python标准库中没有内置的链表类型  

实现链表基于 **自定义类+引用（指针）** 完成，需要自己实现一个类，包含值和指向下一个节点的指针

数组的底层容器是一个动态数组，在内存中是连续的  

但链表利用的是离散的内存，实现任意位置插入和删除的时间复杂度都是 O(1)：因为**只修改了指针**而没有改变数据实际的*存放位置*  


